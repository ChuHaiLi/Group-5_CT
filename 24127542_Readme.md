Smart Travel Project Implementation

This section provides a comprehensive, production-ready Python codebase for the Smart Travel Project. The implementation is organized into modular components, each fulfilling parts of the provided roadmap:

Schema Validation: Uses Python’s jsonschema library to validate user profiles and queries. It gathers all validation errors (not just the first) using the Draft7Validator.iter_errors approach
stackoverflow.com
 for detailed feedback.

Taxonomy Normalization: A mapping of user-entered preference keywords (e.g. "chill", "culinary") to standardized internal categories (e.g. "relax", "foodie") is included for consistent handling of preferences.

Budget Normalization with Currency Conversion: A stubbed currency converter normalizes budget values to a target currency (e.g. converting EUR to USD or vice versa) using fixed exchange rates. Currency codes are expected as three-letter ISO 4217 codes (e.g. USD, EUR)
currencysystem.com
.

Data Transfer Objects (DTOs): Defined via Python dataclasses to represent the normalized user profile and query data structures.

Fixtures and Testing: Sample valid and invalid user profiles/queries are provided, along with a test runner that validates them and prints detailed error reports. An integration preview simulates a form submission through the normalizer → validator → (mock) API response pipeline.

Command-Line Interface (CLI): A user-friendly CLI (using argparse) ties everything together, allowing execution in either test mode (to run validations on sample data) or preview mode (to simulate a full end-to-end scenario).

All code is written with type hints, docstrings, and careful error handling for clarity and maintainability. The sections below outline each module with its purpose and implementation.

schemas.py

This module defines the JSON Schema specifications for a user profile and a user query. These schemas enforce required fields, data types, and simple formats (like date strings and currency codes) for input validation.

"""
Schemas for user profile and user query validation in the Smart Travel Project.
Defines the expected JSON structure and constraints for each.
"""
# JSON Schema definitions for the user profile and user query data.

user_profile_schema = {
    "type": "object",
    "properties": {
        "name": {"type": "string", "minLength": 1},
        "age": {"type": "integer", "minimum": 0},
        "preferences": {
            "type": "array",
            "items": {
                "type": "string",
                "enum": ["relax", "foodie", "adventure", "culture"]
            }
        },
        "preferred_currency": {
            "type": "string",
            "pattern": "^[A-Z]{3}$"  # ISO 4217 currency code, e.g. USD, EUR:contentReference[oaicite:2]{index=2}
        }
    },
    "required": ["name", "preferences"],
    "additionalProperties": False
}

user_query_schema = {
    "type": "object",
    "properties": {
        "destination": {"type": "string", "minLength": 1},
        "start_date": {
            "type": "string",
            "pattern": "^\\d{4}-\\d{2}-\\d{2}$"  # format YYYY-MM-DD (simplified)
        },
        "end_date": {
            "type": "string",
            "pattern": "^\\d{4}-\\d{2}-\\d{2}$"
        },
        "budget_amount": {"type": "number", "minimum": 0},
        "budget_currency": {
            "type": "string",
            "pattern": "^[A-Z]{3}$"  # 3-letter currency code:contentReference[oaicite:3]{index=3}
        }
    },
    "required": ["destination", "start_date", "end_date", "budget_amount", "budget_currency"],
    "additionalProperties": False
}

normalizer.py

This module handles input normalization. It maps user-entered preferences to canonical taxonomy codes and converts budget amounts to a unified currency. It also defines DTO classes (UserProfileDTO and UserQueryDTO) as convenient structured representations of the normalized data.

"""
Normalization module for the Smart Travel Project.
- Maps user-entered preference keywords to standardized internal codes (taxonomy).
- Normalizes budget values by converting currencies to a target currency.
- Provides data transfer object (DTO) classes for user profile and query.
"""
from dataclasses import dataclass, asdict
from typing import List, Optional

# Define data transfer object classes for user profile and user query.
@dataclass
class UserProfileDTO:
    """Data Transfer Object for a user profile."""
    name: str
    preferences: List[str]
    age: Optional[int] = None
    preferred_currency: str = "USD"

@dataclass
class UserQueryDTO:
    """Data Transfer Object for a user query (trip request)."""
    destination: str
    start_date: str
    end_date: str
    budget_amount: float
    budget_currency: str

# Taxonomy mapping: user-entered preferences to canonical internal categories.
PREFERENCE_SYNONYMS = {
    "chill": "relax",
    "relax": "relax",
    "rest": "relax",
    "culinary": "foodie",
    "foodie": "foodie",
    "food": "foodie"
    # Additional synonyms can be added here as needed.
}

class CurrencyConverterStub:
    """
    Stub for currency conversion.
    Holds static exchange rates relative to a base currency (USD) and provides conversion.
    """
    def __init__(self):
        # Define conversion rates: value = how many USD per 1 unit of currency.
        self.rates = {
            "USD": 1.0,
            "EUR": 1.1,  # 1 EUR = 1.1 USD (example rate)
            "GBP": 1.3,  # 1 GBP = 1.3 USD
            "JPY": 0.009  # 1 JPY = 0.009 USD (i.e., ~111 JPY per USD)
        }
        self.base_currency = "USD"

    def convert(self, amount: float, from_currency: str, to_currency: str) -> float:
        """
        Convert an amount from one currency to another using the stubbed rates.
        Returns the converted amount.
        Raises ValueError if a currency code is unsupported.
        """
        from_currency = from_currency.upper()
        to_currency = to_currency.upper()
        if from_currency not in self.rates or to_currency not in self.rates:
            raise ValueError(f"Currency conversion not supported for {from_currency} or {to_currency}")
        # Convert from source to USD, then USD to target.
        amount_in_usd = amount * self.rates[from_currency]  # convert source to USD
        converted_amount = amount_in_usd / self.rates[to_currency]  # convert USD to target
        return converted_amount

def normalize_preferences(prefs: List[str]) -> List[str]:
    """
    Normalize a list of preference keywords to canonical codes.
    - Synonyms and variants are mapped to standard categories.
    - Duplicates are removed.
    """
    canonical_prefs = []
    for p in prefs:
        key = p.lower().strip()
        # Map to canonical if available, otherwise use the lowercase as is.
        canonical = PREFERENCE_SYNONYMS.get(key, key)
        if canonical not in canonical_prefs:
            canonical_prefs.append(canonical)
    return canonical_prefs

def normalize_profile(raw_profile: dict) -> UserProfileDTO:
    """
    Normalize raw user profile data from a form input into a UserProfileDTO.
    - Trims strings, converts types, and maps preference synonyms.
    """
    name = raw_profile.get("name", "").strip()
    age_val = raw_profile.get("age")
    if isinstance(age_val, str):
        # Try to convert age from string to int if possible.
        age_val = age_val.strip()
        if age_val.isdigit():
            age_val = int(age_val)
        else:
            # Not a pure number string.
            raise ValueError(f"Invalid age value: {age_val}")
    # If age_val is not provided or remains non-numeric, it will stay as None.
    preferences_raw = raw_profile.get("preferences", [])
    # If preferences were provided as a comma-separated string, split them.
    if isinstance(preferences_raw, str):
        preferences_list = [item.strip() for item in preferences_raw.split(",")]
    else:
        preferences_list = preferences_raw
    # Map synonyms in preferences to canonical values.
    preferences_norm = normalize_preferences(preferences_list)
    # Normalize preferred_currency to uppercase or default to USD.
    pref_currency = raw_profile.get("preferred_currency")
    if pref_currency:
        pref_currency = pref_currency.upper().strip()
        # If a currency symbol was given instead of code, map common symbols.
        symbol_map = {"$": "USD", "€": "EUR", "£": "GBP", "¥": "JPY"}
        if pref_currency in symbol_map:
            pref_currency = symbol_map[pref_currency]
        # Validate length is 3 (ISO code) if not handled by later validation.
    else:
        pref_currency = "USD"
    # Construct and return the DTO.
    return UserProfileDTO(
        name=name,
        age=age_val,
        preferences=preferences_norm,
        preferred_currency=pref_currency
    )

def normalize_query(raw_query: dict, profile: Optional[UserProfileDTO] = None) -> UserQueryDTO:
    """
    Normalize raw user query data from a form input into a UserQueryDTO.
    - Converts numeric fields from strings, normalizes date format, and applies currency conversion.
    """
    destination = raw_query.get("destination", "").strip()
    # Normalize date format (e.g., replace '/' with '-' if needed)
    start_date = raw_query.get("start_date", "").strip()
    end_date = raw_query.get("end_date", "").strip()
    if "/" in start_date:
        start_date = start_date.replace("/", "-")
    if "/" in end_date:
        end_date = end_date.replace("/", "-")
    # Convert budget amount to float if it's a string.
    amount_val = raw_query.get("budget_amount")
    if isinstance(amount_val, str):
        amount_str = amount_val.strip()
        # Check if the string contains a currency symbol (like $ or €)
        symbol_map = {"$": "USD", "€": "EUR", "£": "GBP", "¥": "JPY"}
        if amount_str and amount_str[0] in symbol_map:
            # Extract symbol and update budget_currency if not already provided.
            symbol = amount_str[0]
            amount_str = amount_str[1:].strip()
            if not raw_query.get("budget_currency"):
                raw_query["budget_currency"] = symbol_map[symbol]
        # Remove any commas in the number (e.g., "1,000")
        amount_str = amount_str.replace(",", "")
        try:
            amount_val = float(amount_str)
        except ValueError:
            raise ValueError(f"Invalid budget amount format: {amount_val}")
    # Determine source and target currencies for normalization.
    currency = raw_query.get("budget_currency", "")
    currency = currency.upper().strip() if currency else ""
    target_currency = "USD"
    if profile:
        # Use profile's preferred currency if available.
        target_currency = profile.preferred_currency or "USD"
        target_currency = target_currency.upper()
    # If no currency specified in query, use target_currency as the assumed input currency too.
    if not currency:
        currency = target_currency
    # Convert currency if needed.
    normalized_amount = amount_val
    normalized_currency = currency
    if currency and target_currency and currency.upper() != target_currency.upper():
        converter = CurrencyConverterStub()
        normalized_amount = converter.convert(amount_val, currency, target_currency)
        # Round to 2 decimal places for currency value.
        normalized_amount = round(normalized_amount, 2)
        normalized_currency = target_currency
    # Construct and return the DTO.
    return UserQueryDTO(
        destination=destination,
        start_date=start_date,
        end_date=end_date,
        budget_amount=normalized_amount,
        budget_currency=normalized_currency
    )

validator.py

The validator module uses the jsonschema library to check if given profile or query data conforms to the schemas defined in schemas.py. It returns all validation errors with field-specific messages for clarity. We leverage JSON Schema’s Draft 7 validator for comprehensive validation (e.g., type checking, required fields, pattern matching). By using iter_errors(), we collect all errors at once instead of halting at the first error
stackoverflow.com
.

"""
Validation module using JSON Schema for the Smart Travel Project.
Provides functions to validate user profile and query data against defined schemas.
"""
import jsonschema
from jsonschema import Draft7Validator
# Import the schema definitions
import schemas

def validate_data(data: dict, schema: dict) -> list:
    """
    Validate a data dict against a given JSON schema.
    Returns a list of error messages, or an empty list if validation passes.
    """
    # Use Draft7Validator.iter_errors to collect all errors:contentReference[oaicite:5]{index=5}
    validator = Draft7Validator(schema)
    errors = sorted(validator.iter_errors(data), key=lambda e: e.path)
    error_messages = []
    for error in errors:
        # Construct a readable error message with context.
        field_path = ".".join([str(p) for p in error.path])  # field path in the data
        if field_path:
            error_messages.append(f"{field_path}: {error.message}")
        else:
            error_messages.append(f"{error.message}")
    return error_messages

def validate_profile(profile: dict) -> list:
    """Validate a user profile dictionary against the user_profile_schema."""
    return validate_data(profile, schemas.user_profile_schema)

def validate_query(query: dict) -> list:
    """Validate a user query dictionary against the user_query_schema."""
    return validate_data(query, schemas.user_query_schema)

fixtures.py

This module provides hardcoded fixtures – sample data to test the system. It includes lists of valid and invalid user_profile and user_query examples. The invalid cases are designed to trigger different validation errors (missing fields, wrong types, format violations, etc.) to ensure our validator catches them.

"""
Fixtures for testing the Smart Travel Project modules.
Contains sample valid and invalid user profiles and user queries.
"""
# Valid user profile examples
valid_user_profiles = [
    {
        "name": "Alice",
        "age": 30,
        "preferences": ["relax", "foodie"],
        "preferred_currency": "USD"
    },
    {
        "name": "Bob",
        "preferences": ["culture"]
    }
]

# Valid user query examples
valid_user_queries = [
    {
        "destination": "Paris",
        "start_date": "2025-12-01",
        "end_date": "2025-12-10",
        "budget_amount": 1500,
        "budget_currency": "EUR"
    },
    {
        "destination": "Tokyo",
        "start_date": "2025-11-15",
        "end_date": "2025-11-20",
        "budget_amount": 200000,
        "budget_currency": "JPY"
    }
]

# Invalid user profile examples
invalid_user_profiles = [
    {
        "name": "Charlie",
        "age": "thirty",         # age should be an integer, not a string
        "preferences": ["relax"]
    },
    {
        # Missing name (required field)
        "age": 25,
        "preferences": ["foodie"]
    },
    {
        "name": "Dana",
        "preferences": "relax"   # preferences should be an array, not a string
    },
    {
        "name": "Eve",
        "preferences": ["relax"],
        "preferred_currency": "usd"  # currency code should be uppercase (ISO 4217)
    }
]

# Invalid user query examples
invalid_user_queries = [
    {
        # Missing end_date (required field)
        "destination": "Paris",
        "start_date": "2025-12-01",
        "budget_amount": 1000,
        "budget_currency": "USD"
    },
    {
        "destination": "London",
        "start_date": "2025/05/10",   # wrong date format (should be YYYY-MM-DD)
        "end_date": "2025/05/15",
        "budget_amount": 500,
        "budget_currency": "GBP"
    },
    {
        "destination": "Rome",
        "start_date": "2025-08-01",
        "end_date": "2025-08-05",
        "budget_amount": "five hundred",  # budget_amount should be a number
        "budget_currency": "EUR"
    },
    {
        "destination": "NYC",
        "start_date": "2025-09-01",
        "end_date": "2025-09-10",
        "budget_amount": -300,     # negative budget not allowed (min 0)
        "budget_currency": "USD"
    }
]

cli.py

The CLI module ties everything together, providing a command-line interface to run the project in different modes. We utilize Python’s argparse to define two options:

--test: Runs the validation test suite using the fixtures, printing out results for each test case (and clearly indicating any errors found).

--preview: Runs an integration preview, simulating a user filling out a travel request. This will normalize the input, validate it, and then (if valid) output a mock API response.

The CLI ensures each step is reported to the console so a developer or tester can follow the transformations from raw input to normalized DTOs to validation and final output.

"""
Command-Line Interface for the Smart Travel Project.
Allows running in preview mode (simulate a user scenario) or test mode (run validation tests).
"""
import argparse
import normalizer
import validator
import fixtures

def run_validation_tests():
    """Run validation tests on sample data and report results."""
    print("== Running Validation Tests ==")
    # Test valid user profiles
    print("\nValid User Profiles:")
    for i, profile in enumerate(fixtures.valid_user_profiles, start=1):
        errors = validator.validate_profile(profile)
        if not errors:
            print(f"Profile #{i} (name: {profile.get('name')}): OK")
        else:
            print(f"Profile #{i} (name: {profile.get('name', '<unnamed>')}): FAILED")
            for err in errors:
                print(f"  - {err}")
    # Test invalid user profiles
    print("\nInvalid User Profiles:")
    for i, profile in enumerate(fixtures.invalid_user_profiles, start=1):
        errors = validator.validate_profile(profile)
        if errors:
            print(f"Profile #{i} (invalid case): correctly caught errors")
            for err in errors:
                print(f"  - {err}")
        else:
            print(f"Profile #{i} (invalid case): ERROR - was expected to fail validation but passed.")
    # Test valid user queries
    print("\nValid User Queries:")
    for i, query in enumerate(fixtures.valid_user_queries, start=1):
        errors = validator.validate_query(query)
        if not errors:
            print(f"Query #{i} (destination: {query.get('destination')}): OK")
        else:
            print(f"Query #{i} (destination: {query.get('destination', '<no dest>')}): FAILED")
            for err in errors:
                print(f"  - {err}")
    # Test invalid user queries
    print("\nInvalid User Queries:")
    for i, query in enumerate(fixtures.invalid_user_queries, start=1):
        errors = validator.validate_query(query)
        if errors:
            print(f"Query #{i} (invalid case): correctly caught errors")
            for err in errors:
                print(f"  - {err}")
        else:
            print(f"Query #{i} (invalid case): ERROR - was expected to fail validation but passed.")

def run_integration_preview():
    """Simulate a full form submission through normalization, validation, and mock API response."""
    print("== Running Integration Preview ==")
    # Example raw user input (with some unnormalized values)
    raw_profile = {
        "name": "John Doe",
        "age": 28,
        "preferences": ["chill", "culinary"],  # uses synonyms that will be normalized
        "preferred_currency": "EUR"
    }
    raw_query = {
        "destination": "New York",
        "start_date": "2025-12-20",
        "end_date": "2025-12-30",
        "budget_amount": 1000,
        "budget_currency": "USD"
    }
    print("Raw user profile input:", raw_profile)
    print("Raw user query input:", raw_query)
    # Normalize the inputs
    try:
        profile_dto = normalizer.normalize_profile(raw_profile)
        query_dto = normalizer.normalize_query(raw_query, profile_dto)
    except Exception as e:
        print("Error during normalization:", e)
        return
    normalized_profile = normalizer.asdict(profile_dto)
    normalized_query = normalizer.asdict(query_dto)
    print("\nNormalized Profile:", normalized_profile)
    print("Normalized Query:", normalized_query)
    # Validate the normalized data
    profile_errors = validator.validate_profile(normalized_profile)
    query_errors = validator.validate_query(normalized_query)
    if profile_errors or query_errors:
        print("\nValidation errors were found:")
        for err in profile_errors:
            print(f"  Profile error: {err}")
        for err in query_errors:
            print(f"  Query error: {err}")
        print("Cannot proceed to API call due to validation errors.")
    else:
        print("\nValidation passed. Proceeding to mock API call...")
        # Simulate a successful API call/response
        response = {
            "status": "success",
            "itinerary": [
                "Day 1: Explore central New York and famous landmarks.",
                "Day 2: Enjoy local cuisine and a Broadway show.",
                # ... further days could be listed
            ],
            "total_budget": f"{query_dto.budget_currency} {query_dto.budget_amount:.2f}"
        }
        print("Mock API response:", response)

def main():
    parser = argparse.ArgumentParser(description="Smart Travel Project CLI")
    parser.add_argument("--test", action="store_true", help="Run validation tests on sample data.")
    parser.add_argument("--preview", action="store_true", help="Run an integration preview of the full pipeline.")
    args = parser.parse_args()
    if not args.test and not args.preview:
        parser.print_help()
        return
    if args.test:
        run_validation_tests()
    if args.preview:
        if args.test:
            print("\n")  # blank line separator if both modes are run
        run_integration_preview()

if __name__ == "__main__":
    main()

Usage Instructions

Prerequisites: Ensure you have Python 3.10+ installed. You will also need the jsonschema library for JSON Schema validation (install via pip install jsonschema).

Running Tests:
Use the test mode to validate the sample profiles and queries. This will print each case and highlight any validation errors. For example:

python cli.py --test


Sample output excerpt for --test (showing some validation results):

== Running Validation Tests ==

Valid User Profiles:
Profile #1 (name: Alice): OK
Profile #2 (name: Bob): OK

Invalid User Profiles:
Profile #1 (invalid case): correctly caught errors
  - age: 'thirty' is not of type 'integer'
Profile #2 (invalid case): correctly caught errors
  - 'name' is a required property
...
Invalid User Queries:
Profile #3 (invalid case): correctly caught errors
  - budget_amount: 'five hundred' is not of type 'number'
Profile #4 (invalid case): correctly caught errors
  - budget_amount: -300 is less than the minimum of 0


As shown, the test runner outputs OK for valid cases and lists specific error messages for each invalid case (e.g., missing required fields, type mismatches, format violations).

Running Integration Preview:
Use the preview mode to simulate an end-to-end scenario with a sample input. This will show the raw input, normalized output, and then either validation errors or a mock successful API response. For example:

python cli.py --preview


Expected output will detail each step. For instance, you should see something like:

== Running Integration Preview ==
Raw user profile input: {'name': 'John Doe', 'age': 28, 'preferences': ['chill', 'culinary'], ...}
Raw user query input: {'destination': 'New York', 'start_date': '2025-12-20', ...}

Normalized Profile: {'name': 'John Doe', 'preferences': ['relax', 'foodie'], 'age': 28, 'preferred_currency': 'EUR'}
Normalized Query: {'destination': 'New York', ... 'budget_amount': 909.09, 'budget_currency': 'EUR'}

Validation passed. Proceeding to mock API call...
Mock API response: {'status': 'success', 'itinerary': ['Day 1: ...', 'Day 2: ...'], 'total_budget': 'EUR 909.09'}


Here the raw inputs include unstandardized preferences ("chill", "culinary") and a budget in USD. After running through the normalizer, the preferences are mapped to ["relax", "foodie"] and the budget is converted to EUR (John Doe’s preferred currency) with the amount adjusted (1000 USD -> 909.09 EUR given our stubbed rate). The validator then confirms all data is valid, and the CLI prints a mock API response (in a real system, this is where an external service would be invoked to generate travel plans).

Extensibility: This codebase is structured for maintainability. New preference synonyms can be added to PREFERENCE_SYNONYMS in normalizer.py, more complex schema rules can be introduced in schemas.py, and real currency conversion logic or API calls can replace the stubs when moving from this prototype to production. The CLI provides a basic interface that could be expanded (e.g., to accept file inputs or user-provided data) as needed.